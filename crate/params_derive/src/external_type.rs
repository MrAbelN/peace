use proc_macro2::Span;
use syn::{DeriveInput, Fields, FieldsUnnamed, Ident, Path, PathArguments, Type};

use crate::{
    type_gen_external::{type_gen_external, External},
    util::{is_external, type_path_name_and_generics, type_path_simple_name},
    TypeGen,
};

/// Consolidates all the logic to wrap external types together.
///
/// This should make it easier to trace wherever external type logic is used, by
/// searching for `ExternalType::`.
pub struct ExternalType;

impl ExternalType {
    /// Implements external wrapper types for Params' fields that are defined by
    /// external crates.
    pub fn external_wrapper_types(
        ast: &DeriveInput,
        peace_params_path: &Path,
    ) -> proc_macro2::TokenStream {
        match &ast.data {
            syn::Data::Struct(data_struct) => {
                let fields_iter = data_struct.fields.iter();
                external_wrapper_types_impl!(fields_iter, peace_params_path)
            }
            syn::Data::Enum(data_enum) => {
                let fields_iter = data_enum
                    .variants
                    .iter()
                    .flat_map(|variant| variant.fields.iter());
                external_wrapper_types_impl!(fields_iter, peace_params_path)
            }
            syn::Data::Union(data_union) => {
                let fields_iter = data_union.fields.named.iter();
                external_wrapper_types_impl!(fields_iter, peace_params_path)
            }
        }
    }

    /// Generates `ThingWrapper` and `ThingWrapperPartial`.
    ///
    /// This used when `Thing` is an external type to both `peace` and the item
    /// spec crate, but is used as a `Value` within an `ItemSpec::Params`.
    ///
    /// # Parameters
    ///
    /// * `type_name`: Name of the type to generate.
    /// * `wrapper_type`: `Type` of the wrapper to generate, generated by
    ///   `ExternalType::wrapper_type`.
    /// * `wrapped_ty`: `Type` of the field that is external, e.g. `Thing`.
    pub fn wrapper_and_related_types_gen(
        peace_params_path: &Path,
        wrapper_type: &Type,
        wrapped_ty: &Type,
    ) -> proc_macro2::TokenStream {
        let wrapper_partial_type = Self::wrapper_partial_type(wrapped_ty);
        let Some(wrapper_partial_name) = type_path_simple_name(&wrapper_partial_type) else {
            unreachable!("Type must be present at this stage.");
        };
        let Some((wrapper_name, generics)) = type_path_name_and_generics(wrapper_type) else {
            unreachable!("Type must be present at this stage.");
        };

        let mut tokens = Self::wrapper_gen(
            peace_params_path,
            wrapper_name,
            generics,
            wrapped_ty,
            wrapper_partial_name,
        );
        tokens.extend(Self::wrapper_partial_gen(
            wrapper_name,
            &wrapper_partial_type,
            wrapped_ty,
        ));

        tokens
    }

    /// Generates `ThingWrapper` and `ThingWrapperPartial`.
    ///
    /// This used when `Thing` is an external type to both `peace` and the item
    /// spec crate, but is used as a `Value` within an `ItemSpec::Params`.
    ///
    /// # Parameters
    ///
    /// * `peace_params_path`: One of `peace::params`, `peace_params`, or
    ///   `crate::params`.
    /// * `wrapper_type`: `Type` of the wrapper to generate, generated by
    ///   `ExternalType::wrapper_type`.
    /// * `wrapped_ty`: `Type` of the field that is external, e.g. `Thing`.
    fn wrapper_gen(
        peace_params_path: &Path,
        wrapper_name: &Ident,
        generics: &PathArguments,
        wrapped_ty: &Type,
        wrapper_partial_name: &Ident,
    ) -> proc_macro2::TokenStream {
        let fields_unnamed: FieldsUnnamed = parse_quote!((#wrapped_ty));
        let fields = Fields::from(fields_unnamed);

        let struct_constructor = TypeGen::struct_constructor(wrapper_name, &fields);
        let struct_fields_clone = TypeGen::struct_fields_clone(wrapper_name, &fields);
        let struct_fields_debug = TypeGen::struct_fields_debug(wrapper_name, &fields);

        quote! {
            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct #wrapper_name #generics #fields;

            impl #generics #wrapper_name #generics {
                #struct_constructor
            }

            impl #generics ::std::clone::Clone
            for #wrapper_name #generics
            {
                fn clone(&self) -> Self {
                    #struct_fields_clone
                }
            }

            impl #generics ::std::fmt::Debug
            for #wrapper_name #generics
            {
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    #struct_fields_debug
                }
            }

            impl #generics #peace_params_path::Value
            for #wrapper_name #generics
            {
                type Spec = #peace_params_path::ValueSpec<#wrapper_name #generics>;
                type Partial = #wrapper_partial_name #generics;
            }

            // impl From<ThingWrapper> for Thing
            impl #generics ::std::convert::From<#wrapper_name #generics>
            for #wrapped_ty
            {
                fn from(wrapper: #wrapper_name #generics) -> Self {
                    wrapper.0
                }
            }
        }
    }

    /// Generates `ThingWrapper` and `ThingWrapperPartial`.
    ///
    /// This used when `Thing` is an external type to both `peace` and the item
    /// spec crate, but is used as a `Value` within an `ItemSpec::Params`.
    ///
    /// # Parameters
    ///
    /// * `wrapper_partial_type`: `Type` of the wrapper to generate, generated
    ///   by `ExternalType::wrapper_partial_type`.
    /// * `wrapped_ty`: `Type` of the field that is external, e.g. `Thing`.
    fn wrapper_partial_gen(
        wrapper_name: &Ident,
        wrapper_partial_type: &Type,
        wrapped_ty: &Type,
    ) -> proc_macro2::TokenStream {
        let ast: DeriveInput = parse_quote!(pub struct #wrapped_ty;);
        let generics_split = ast.generics.split_for_impl();
        let Some(wrapper_partial_name) = type_path_simple_name(wrapper_partial_type) else {
            unreachable!("Type must be present at this stage.");
        };
        let Some(value_name) = type_path_simple_name(wrapped_ty) else {
            unreachable!("Type must be present at this stage.");
        };

        type_gen_external(
            &ast,
            &generics_split,
            External::Wrapper {
                value_name,
                wrapper_name,
            },
            wrapper_partial_name,
            &[parse_quote!(#[derive(serde::Serialize, serde::Deserialize)])],
        )
    }

    /// Returns the wrapper type name.
    ///
    /// In practice, `Thing<T>` will generate `ThingWrapper<T>`, but this may
    /// change in the future, e.g. to avoid name collisions.
    pub fn wrapper_type(ty: &Type) -> Type {
        match ty {
            Type::Path(type_path) => {
                let Some(field_type_segment) = type_path.path.segments.last() else {
                    unreachable!("Field type must have at least one segment.");
                };
                let field_type_name = &field_type_segment.ident;
                let field_generics = &field_type_segment.arguments;
                let wrapper_type_name =
                    Ident::new(&format!("{field_type_name}Wrapper"), Span::call_site());

                parse_quote!(#wrapper_type_name #field_generics)
            }

            // Type::Array(_)
            // | Type::BareFn(_)
            // | Type::Group(_)
            // | Type::ImplTrait(_)
            // | Type::Infer(_)
            // | Type::Macro(_)
            // | Type::Never(_)
            // | Type::Paren(_)
            // | Type::Ptr(_)
            // | Type::Reference(_)
            // | Type::Slice(_)
            // | Type::TraitObject(_)
            // | Type::Tuple(_)
            // | Type::Verbatim(_)
            _ => panic!(
                "Unsupported type to generate wrapper: {ty}",
                ty = quote!(#ty)
            ),
        }
    }

    /// Returns the wrapper partial type name.
    ///
    /// In practice, `Thing<T>` will generate `ThingWrapperPartial<T>`, but this
    /// may change in the future, e.g. to avoid name collisions.
    pub fn wrapper_partial_type(ty: &Type) -> Type {
        match ty {
            Type::Path(type_path) => {
                let Some(field_type_segment) = type_path.path.segments.last() else {
                    unreachable!("Field type must have at least one segment.");
                };
                let field_type_name = &field_type_segment.ident;
                let field_generics = &field_type_segment.arguments;
                let wrapper_partial_type_name = Ident::new(
                    &format!("{field_type_name}WrapperPartial"),
                    Span::call_site(),
                );

                parse_quote!(#wrapper_partial_type_name #field_generics)
            }

            // Type::Array(_)
            // | Type::BareFn(_)
            // | Type::Group(_)
            // | Type::ImplTrait(_)
            // | Type::Infer(_)
            // | Type::Macro(_)
            // | Type::Never(_)
            // | Type::Paren(_)
            // | Type::Ptr(_)
            // | Type::Reference(_)
            // | Type::Slice(_)
            // | Type::TraitObject(_)
            // | Type::Tuple(_)
            // | Type::Verbatim(_)
            _ => panic!(
                "Unsupported type to generate wrapper: {ty}",
                ty = quote!(#ty)
            ),
        }
    }
}

macro_rules! external_wrapper_types_impl {
    ($fields_iter:ident, $peace_params_path:ident) => {
        $fields_iter
            .filter_map(|field| {
                if is_external(&field.attrs) {
                    let field_ty = &field.ty;
                    let wrapper_type = ExternalType::wrapper_type(field_ty);
                    Some((wrapper_type, field_ty))
                } else {
                    None
                }
            })
            .fold(
                proc_macro2::TokenStream::new(),
                |mut tokens, (wrapper_type, field_ty)| {
                    tokens.extend(ExternalType::wrapper_and_related_types_gen(
                        $peace_params_path,
                        &wrapper_type,
                        field_ty,
                    ));
                    tokens
                },
            )
    };
}

use external_wrapper_types_impl;
